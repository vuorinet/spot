{% set entries = vm.entries %}
{% set max_total = vm.maxTotal %}
{% set chart_date = request.query_params.get('date', 'today') %}
{% set chart_id = 'googleChart_' ~ chart_date %}
{% set date_string_id = 'dateString_' ~ chart_date %}
<section id="{{ chart_date }}Chart" class="chart" aria-label="Prices chart" data-date="{{ chart_date }}"
    data-margin="{{ request.query_params.get('margin', '0') }}">
    <div class="chart-head">
        {{ chart_date|title }}
        <span class="date-string" id="{{ date_string_id }}"></span>
    </div>
    <div class="chart-body">
        <div id="{{ chart_id }}" style="width: 100%; height: 100%;"></div>
    </div>
</section>

<script>
    // Create chart for {{ chart_date }}
    window.createChart_{{chart_date }} = function() {
        const date = '{{ chart_date }}';
        const margin = '{{ request.query_params.get('margin', '0') }}';
        const chartElement = document.getElementById('{{ chart_id }}');
        const dateStringEl = document.getElementById('{{ date_string_id }}');

        if (!chartElement) {
            console.error('Chart element not found:', '{{ chart_id }}');
            return;
        }

        // Check if we already have cached data and chart instance for this element
        if (chartElement._chartInstance && chartElement._chartData && chartElement._originalPriceRange) {
            console.log('Redrawing existing chart for {{ chart_date }} without fetching new data');

            // Recalculate responsive options since viewport may have changed
            const isMobile = window.innerWidth <= 900;
            const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
            const options = {
                title: '',
                hAxis: {
                    title: '',
                    textStyle: {
                        fontSize: isMobile ? 10 : 12,
                        color: 'white'
                    },
                    titleTextStyle: {
                        color: 'white',
                        fontSize: isMobile ? 10 : 12
                    },
                    slantedText: false,
                    format: 'none',
                    gridlines: { count: -1 },
                    // Custom ticks for 15-minute data to show only hours
                    ticks: (() => {
                        const granularity = chartElement._granularity || 'hour';
                        if (granularity === 'quarter_hour') {
                            const ticks = [];
                            // Create ticks at every 4th position (0, 4, 8, 12, ...)
                            for (let hour = 0; hour < 24; hour++) {
                                const position = hour * 4;
                                ticks.push({ v: position.toString(), f: hour.toString() });
                            }
                            console.log('Using custom ticks for redraw (15-min):', ticks.slice(0, 5));
                            return ticks;
                        } else {
                            // For hourly data, let Google Charts handle it
                            return undefined;
                        }
                    })(),
                    // Force exactly 24 ticks for hourly data only
                    count: (() => {
                        const granularity = chartElement._granularity || 'hour';
                        return granularity === 'quarter_hour' ? undefined : 24;
                    })(),
                    maxAlternation: 1,
                    minTextSpacing: isTablet ? 8 : (isMobile ? 0 : 10),
                    maxTextLines: 1,
                    allowContainerBoundaryTextCutoff: false,
                    // Force single row display and optimize spacing
                    textPosition: 'out'
                },
                vAxis: {
                    title: '',
                    minValue: chartElement._originalPriceRange.minPrice,
                    maxValue: chartElement._originalPriceRange.maxPrice,
                    viewWindow: {
                        min: chartElement._originalPriceRange.minPrice,
                        max: chartElement._originalPriceRange.maxPrice
                    },
                    ticks: (() => {
                        const ticks = [];
                        const maxValue = chartElement._originalPriceRange.maxPrice;
                        for (let i = chartElement._originalPriceRange.minPrice; i <= maxValue; i += 1) {
                            if (i % 5 === 0) {
                                ticks.push({ v: i, f: i.toString() });
                            } else {
                                ticks.push({ v: i, f: '' });
                            }
                        }
                        return ticks;
                    })(),
                    gridlines: {
                        count: 0, // Disable automatic gridlines completely - use only custom ones
                        color: 'transparent'
                    },
                    minorGridlines: {
                        count: 0 // Disable minor gridlines between major ones
                    },
                    textStyle: {
                        fontSize: isMobile ? 12 : 12, // Increase mobile font size for better visibility
                        color: 'white'
                    },
                    titleTextStyle: {
                        color: 'white',
                        fontSize: isMobile ? 12 : 12
                    }
                },
                isStacked: true,
                backgroundColor: 'black',
                width: '100%',
                height: '100%',
                chartArea: {
                    width: isMobile ? '75%' : '90%', // Reduce width to make room for Y-axis labels
                    height: isMobile ? '85%' : (isTablet ? '50%' : '65%'),  // Much more conservative height for tablets to accommodate x-axis
                    top: isMobile ? 5 : 15,
                    left: isMobile ? 35 : 50, // Increase left margin for Y-axis labels on mobile
                    right: isMobile ? 10 : 5,
                    bottom: isMobile ? 15 : (isTablet ? 60 : 40)  // Optimized space for single-row X-axis labels on tablets
                },
                series: {
                    0: { color: '#2ecc71' }, // Green
                    1: { color: '#f1c40f' }, // Yellow
                    2: { color: '#e74c3c' }, // Red
                    3: { color: '#666666' }  // Gray for margin
                },
                tooltip: {
                    isHtml: true,
                    textStyle: {
                        fontSize: isMobile ? 12 : 14,
                        color: 'black'
                    }
                }
            };

            chartElement._chartInstance.draw(chartElement._chartData, options);

            // Re-add major gridlines and now line after redraw
            setTimeout(() => {
                // Draw major gridlines (every 5 cents)
                drawMajorGridlines(chartElement._chartInstance, chartElement, chartElement._originalPriceRange.minPrice, chartElement._originalPriceRange.maxPrice);

                // Add now line for today's chart
                if (date === 'today' && chartElement._validData) {
                    addNowLine(chartElement._chartInstance, chartElement, chartElement._validData);
                }
            }, 100);

            return;
        }

        console.log('Creating chart for:', date, 'margin:', margin);


        function drawChart() {
            // Convert date to proper format for API
            // Let the server handle timezone conversion - just send today/tomorrow as strings
            let dateStr;
            if (date === 'today') {
                dateStr = 'today';
                console.log('Today chart requesting: today');
            } else if (date === 'tomorrow') {
                dateStr = 'tomorrow';
                console.log('Tomorrow chart requesting: tomorrow');
            } else {
                dateStr = date;
            }

            fetch(`/api/chart-data?date_str=${dateStr}&margin=${margin}`)
                .then(response => response.json())
                .then(data => {
                    console.log('Chart data received for', date, ':', data);

                    // Track when this chart's data was fetched with metadata
                    const fetchTime = Date.now();
                    const fetchDate = new Date(fetchTime);

                    if (window.chartDataTimestamps) {
                        window.chartDataTimestamps[date] = fetchTime;
                        console.log(`Updated ${date} chart data timestamp:`, fetchDate.toLocaleTimeString());
                    }

                    if (window.chartDataMetadata) {
                        window.chartDataMetadata[date] = {
                            fetchedDate: fetchDate.toDateString(),
                            fetchedHour: fetchDate.getHours()
                        };
                        console.log(`Updated ${date} chart metadata:`, window.chartDataMetadata[date]);
                    }
                    console.log('Y-axis range:', data.minPrice, 'to', data.maxPrice);
                    console.log('First few data rows:', data.data.slice(0, 3));
                    console.log('Viewport width:', window.innerWidth, 'isMobile:', window.innerWidth <= 768);

                    // Update date string
                    if (dateStringEl) {
                        dateStringEl.textContent = ` - ${data.dateString}`;
                    }

                    // Handle case where no data is available
                    if (!data.data || data.data.length === 0) {
                        chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">No data available for this date</div>';
                        return;
                    }

                    // Create Google Charts data table
                    const chartData = new google.visualization.DataTable();
                    chartData.addColumn('string', 'Time');
                    chartData.addColumn('number', 'Low Price');
                    chartData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } }); // Tooltip for Low Price
                    chartData.addColumn('number', 'Medium Price');
                    chartData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } }); // Tooltip for Medium Price
                    chartData.addColumn('number', 'High Price');
                    chartData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } }); // Tooltip for High Price
                    chartData.addColumn('number', 'Margin');
                    chartData.addColumn({ type: 'string', role: 'tooltip', p: { html: true } }); // Tooltip for Margin

                    // Validate data before adding rows and add custom tooltips
                    const validData = data.data.filter(row => Array.isArray(row) && row.length === 5);
                    if (validData.length === 0) {
                        chartElement.innerHTML = '<div style="color: white; padding: 20px; text-align: center;">Invalid data format received</div>';
                        return;
                    }

                    // Process data to add custom tooltips for each series
                    const processedData = validData.map(row => {
                        const [timeStr, lowPrice, mediumPrice, highPrice, marginPrice] = row;

                        // Calculate total spot price (sum of low + medium + high)
                        const spotPrice = (lowPrice || 0) + (mediumPrice || 0) + (highPrice || 0);
                        const totalPrice = spotPrice + (marginPrice || 0);

                        // Format time - timeStr is either hour index (hourly) or interval index (15-minute)
                        let timeFormatted;
                        if (data.granularity === 'quarter_hour') {
                            // 15-minute data uses sequential indices (0-95), convert to HH:MM
                            const intervalIndex = parseInt(timeStr);
                            const hour = Math.floor(intervalIndex / 4);
                            const quarter = intervalIndex % 4;
                            const minute = quarter * 15;
                            timeFormatted = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                        } else {
                            // Convert hour number to HH:00 format for hourly data
                            const hour = parseInt(timeStr);
                            timeFormatted = `${hour.toString().padStart(2, '0')}:00`;
                        }

                        // Create a comprehensive tooltip that shows all components
                        const createTooltip = () => {
                            let tooltipContent = `
              <div style="padding: 8px; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.4;">
                <div style="font-weight: bold; margin-bottom: 4px; color: #333;">${timeFormatted}</div>
            `;

                            // Add each price component if it has a value (including negative values)
                            if (lowPrice !== 0 && lowPrice !== null && lowPrice !== undefined) {
                                tooltipContent += `<div style="color: #666;">Price: <strong>${lowPrice.toFixed(2)} c/kWh</strong></div>`;
                            }
                            if (mediumPrice !== 0 && mediumPrice !== null && mediumPrice !== undefined) {
                                tooltipContent += `<div style="color: #666;">Price: <strong>${mediumPrice.toFixed(2)} c/kWh</strong></div>`;
                            }
                            if (highPrice !== 0 && highPrice !== null && highPrice !== undefined) {
                                tooltipContent += `<div style="color: #666;">Price: <strong>${highPrice.toFixed(2)} c/kWh</strong></div>`;
                            }

                            // Always show margin
                            tooltipContent += `<div style="color: #666;">Margin: <strong>${(marginPrice || 0).toFixed(2)} c/kWh</strong></div>`;

                            // Add total with separator
                            tooltipContent += `
                <div style="border-top: 1px solid #ddd; margin-top: 4px; padding-top: 4px; color: #333;">
                  <strong>Total: ${totalPrice.toFixed(2)} c/kWh</strong>
                </div>
              </div>
            `;

                            return tooltipContent.trim();
                        };

                        const tooltip = createTooltip();

                        // Return row with tooltip for each series:
                        // [Time, LowPrice, LowTooltip, MediumPrice, MediumTooltip, HighPrice, HighTooltip, Margin, MarginTooltip]
                        // Use null instead of 0 to make Google Charts skip zero segments entirely
                        // Note: Prices can be negative, so only null out if exactly zero
                        return [
                            timeStr,
                            lowPrice !== 0 ? lowPrice : null, tooltip,        // Low price + tooltip (null only if exactly zero)
                            mediumPrice !== 0 ? mediumPrice : null, tooltip,  // Medium price + tooltip (null only if exactly zero)
                            highPrice !== 0 ? highPrice : null, tooltip,      // High price + tooltip (null only if exactly zero)
                            marginPrice !== 0 ? marginPrice : null, tooltip   // Margin + tooltip (null only if exactly zero)
                        ];
                    });

                    chartData.addRows(processedData);

                    // Responsive chart options based on viewport width
                    const isMobile = window.innerWidth <= 900;
                    const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
                    // Everything above 900px uses the same side-by-side layout

                    const options = {
                        title: '',
                        hAxis: {
                            title: '',  // Remove axis title to save space
                            textStyle: {
                                fontSize: isMobile ? 10 : 12,
                                color: 'white'
                            },
                            titleTextStyle: {
                                color: 'white',
                                fontSize: isMobile ? 10 : 12
                            },
                            slantedText: false,
                            gridlines: {
                                count: 24  // Always use 24 gridlines
                            },
                            // Let Google Charts generate automatic ticks, we'll fix them with post-processing
                            count: data.granularity === 'quarter_hour' ? undefined : 24,
                            maxAlternation: 1,
                            // Force single row display and optimize spacing
                            textPosition: 'out'
                        },
                        vAxis: {
                            title: '',  // Remove Y-axis title completely to save space
                            minValue: data.minPrice,
                            maxValue: Math.max(15, data.maxPrice),  // Ensure minimum of 15 cents
                            viewWindow: {
                                min: data.minPrice,
                                max: Math.max(15, data.maxPrice)      // Ensure minimum of 15 cents
                            },
                            ticks: (() => {
                                const ticks = [];
                                const maxValue = Math.max(15, data.maxPrice);  // Use the same enforced maximum
                                // Add all ticks (1-cent intervals) with custom formatting
                                for (let i = data.minPrice; i <= maxValue; i += 1) {
                                    if (i % 5 === 0) {
                                        // Major tick - show number label
                                        ticks.push({ v: i, f: i.toString() });
                                    } else {
                                        // Minor tick - no label (empty string)
                                        ticks.push({ v: i, f: '' });
                                    }
                                }
                                return ticks;
                            })(),
                            gridlines: {
                                count: 0, // Disable automatic gridlines completely - use only custom ones
                                color: 'transparent'
                            },
                            minorGridlines: {
                                count: 0 // Disable minor gridlines
                            },
                            textStyle: {
                                fontSize: isMobile ? 12 : 12, // Increase mobile font size for better visibility
                                color: 'white'
                            },
                            titleTextStyle: {
                                color: 'white',
                                fontSize: isMobile ? 12 : 12
                            }
                        },
                        isStacked: true,
                        legend: 'none',
                        width: '100%',
                        height: '100%',
                        chartArea: {
                            width: isMobile ? '75%' : '90%', // Reduce width to make room for Y-axis labels
                            height: isMobile ? '85%' : (isTablet ? '50%' : '65%'),  // Much more conservative height for tablets to accommodate x-axis
                            top: isMobile ? 5 : 15,
                            left: isMobile ? 35 : 50, // Increase left margin for Y-axis labels on mobile
                            right: isMobile ? 10 : 5,
                            bottom: isMobile ? 15 : (isTablet ? 60 : 40)  // Optimized space for single-row X-axis labels on tablets
                        },
                        backgroundColor: 'black',
                        series: {
                            0: { color: '#2ecc71' },  // green for low prices
                            1: { color: '#f1c40f' },  // yellow for medium prices
                            2: { color: '#e74c3c' },  // red for high prices
                            3: { color: '#666666' }   // gray for margin
                        },
                        bar: {
                            groupWidth: '70%'
                        },
                        tooltip: {
                            isHtml: true,
                            textStyle: {
                                fontSize: isMobile ? 12 : 14,
                                color: 'black'
                            }
                        }
                    };

                    try {
                        const chart = new google.visualization.ColumnChart(chartElement);

                        // Cache chart instance, data, and price range for future redraws
                        chartElement._chartInstance = chart;
                        chartElement._chartData = chartData;
                        chartElement._validData = validData; // Store for now line redrawing
                        chartElement._granularity = data.granularity; // Store granularity for redrawing
                        chartElement._originalPriceRange = {
                            minPrice: data.minPrice,
                            maxPrice: data.maxPrice
                        };

                        // Add ready event listener to draw major gridlines and today's "now" line
                        google.visualization.events.addListener(chart, 'ready', function () {
                            // Draw major gridlines (every 5 cents) - brighter than minor ones
                            drawMajorGridlines(chart, chartElement, data.minPrice, data.maxPrice);

                            if (date === 'today') {
                                addNowLine(chart, chartElement, validData);
                                // Set up timer to update the now line every minute
                                startNowLineTimer(chart, chartElement, validData);
                            }
                        });

                        // Add simple post-processing to fix X-axis labels
                        if (data.granularity === 'quarter_hour') {
                            google.visualization.events.addListener(chart, 'ready', function() {
                                // Add longer delay to ensure chart is fully rendered after orientation changes
                                setTimeout(() => {
                                    try {
                                        // Find X-axis labels specifically
                                        const svg = chartElement.querySelector('svg');
                                        if (svg) {
                                            const textElements = svg.querySelectorAll('text');
                                            const candidates = [];
                                            
                                            // Find potential X-axis labels
                                            textElements.forEach(textElement => {
                                                const text = textElement.textContent.trim();
                                                if (/^\d+$/.test(text)) {
                                                    const value = parseInt(text);
                                                    if (value >= 0 && value <= 95) {
                                                        const rect = textElement.getBoundingClientRect();
                                                        const chartRect = chartElement.getBoundingClientRect();
                                                        candidates.push({
                                                            element: textElement,
                                                            value: value,
                                                            x: rect.left - chartRect.left,
                                                            y: rect.top - chartRect.top
                                                        });
                                                    }
                                                }
                                            });
                                            
                                            // Find the bottom-most row (X-axis)
                                            if (candidates.length > 0) {
                                                const maxY = Math.max(...candidates.map(c => c.y));
                                                const xAxisCandidates = candidates.filter(c => Math.abs(c.y - maxY) < 10);
                                                
                                                // Sort by X position and redistribute to fill full width
                                                xAxisCandidates.sort((a, b) => a.x - b.x);
                                                
                                                if (xAxisCandidates.length > 0) {
                                                    const leftmostX = xAxisCandidates[0].x;
                                                    const rightmostX = xAxisCandidates[xAxisCandidates.length - 1].x;
                                                    const totalWidth = rightmostX - leftmostX;
                                                    
                                                    // Find actual bar positions and place labels under them
                                                    const hourPositions = [];
                                                    
                                                    // Find all bar elements (rectangles) in the chart
                                                    const bars = svg.querySelectorAll('rect');
                                                    const barPositions = [];
                                                    
                                                    // Detect screen size for responsive bar filtering
                                                    const isMobile = window.innerWidth <= 900;
                                                    const isTablet = window.innerWidth > 900 && window.innerWidth <= 1200;
                                                    const screenType = isMobile ? 'mobile' : (isTablet ? 'tablet' : 'desktop');
                                                    
                                                    console.log(`Screen: ${screenType} (${window.innerWidth}px), Total rect elements: ${bars.length}`);
                                                    
                                                    // Get positions of all bars with responsive filtering
                                                    bars.forEach((bar, index) => {
                                                        const x = parseFloat(bar.getAttribute('x') || 0);
                                                        const width = parseFloat(bar.getAttribute('width') || 0);
                                                        const height = parseFloat(bar.getAttribute('height') || 0);
                                                        const fill = bar.getAttribute('fill') || '';
                                                        
                                                        if (index < 10) {
                                                            console.log(`Rect ${index}: x=${x}, width=${width}, height=${height}, fill=${fill}`);
                                                        }
                                                        
                                                        // Responsive filtering criteria based on screen size
                                                        const maxBarWidth = isMobile ? 20 : (isTablet ? 30 : 50);
                                                        const minBarX = isMobile ? 20 : (isTablet ? 30 : 50);
                                                        
                                                        // Filter for data bars: reasonable width, has color fill, reasonable position
                                                        if (width > 0 && width < maxBarWidth && x >= minBarX && height > 0 && fill && fill !== '#ffffff' && fill !== '#000000') {
                                                            barPositions.push({
                                                                x: x,
                                                                width: width,
                                                                centerX: x + width / 2,
                                                                height: height,
                                                                fill: fill
                                                            });
                                                        }
                                                    });
                                                    
                                                    // Sort bars by X position
                                                    barPositions.sort((a, b) => a.x - b.x);
                                                    
                                                    // Remove duplicates (same x position)
                                                    const uniqueBarPositions = [];
                                                    let lastX = -1;
                                                    barPositions.forEach(bar => {
                                                        if (Math.abs(bar.x - lastX) > 0.1) { // Different position (tolerance for floating point)
                                                            uniqueBarPositions.push(bar);
                                                            lastX = bar.x;
                                                        }
                                                    });
                                                    
                                                    console.log(`${screenType} filtering: maxWidth=${isMobile ? 20 : (isTablet ? 30 : 50)}, minX=${isMobile ? 20 : (isTablet ? 30 : 50)}`);
                                                    console.log(`Filtered to ${barPositions.length} valid bars, ${uniqueBarPositions.length} unique bars`);
                                                    
                                                    // Check if we have the expected number of bars (should be 96 for 15-minute data)
                                                    if (uniqueBarPositions.length < 90) {
                                                        console.warn(`Warning: Only found ${uniqueBarPositions.length} bars, expected ~96. Chart may still be rendering.`);
                                                        // Could add a retry mechanism here if needed
                                                    }
                                                    
                                                    console.log('First 12 unique bar details:', uniqueBarPositions.slice(0, 12).map((b, i) => 
                                                        `${i}: x=${b.x.toFixed(1)}, center=${b.centerX.toFixed(1)}, w=${b.width.toFixed(1)}`
                                                    ));
                                                    
                                                    // Position hour labels at the left edge of every 4th bar (1st, 5th, 9th, 13th, ...)
                                                    for (let hour = 0; hour < 24; hour++) {
                                                        const barIndex = hour * 4; // 0, 4, 8, 12, ...
                                                        if (barIndex < uniqueBarPositions.length) {
                                                            // Use the left X position of the bar instead of center
                                                            hourPositions.push(uniqueBarPositions[barIndex].x);
                                                        } else {
                                                            // If we don't have enough bars, extrapolate using left positions
                                                            const lastBarX = uniqueBarPositions[uniqueBarPositions.length - 1].x;
                                                            const barSpacing = uniqueBarPositions.length > 1 ? 
                                                                (uniqueBarPositions[uniqueBarPositions.length - 1].x - uniqueBarPositions[0].x) / (uniqueBarPositions.length - 1) : 20;
                                                            const extrapolatedX = lastBarX + (barIndex - uniqueBarPositions.length + 1) * barSpacing;
                                                            hourPositions.push(extrapolatedX);
                                                            
                                                            if (hour < 15) {
                                                                console.log(`Hour ${hour}: extrapolated to x=${extrapolatedX.toFixed(1)} (barIndex=${barIndex}, lastBar=${lastBarX.toFixed(1)})`);
                                                            }
                                                        }
                                                    }
                                                    
                                                    console.log(`Found ${xAxisCandidates.length} X-axis label candidates for ${screenType} layout`);
                                                    console.log('Original positions:', xAxisCandidates.slice(0, 8).map((c, i) => `${i}: ${c.x.toFixed(1)}`));
                                                    console.log('Target positions:', hourPositions.slice(0, 8).map((x, i) => `${i}: ${x.toFixed(1)}`));
                                                    
                                                    // Calculate baseline Y position once for all labels
                                                    const availableCandidates = Math.min(xAxisCandidates.length, 24);
                                                    const yPositions = xAxisCandidates.slice(0, availableCandidates).map(c => Math.round(c.y));
                                                    const yFrequency = {};
                                                    yPositions.forEach(y => yFrequency[y] = (yFrequency[y] || 0) + 1);
                                                    const baselineY = parseInt(Object.keys(yFrequency).reduce((a, b) => yFrequency[a] > yFrequency[b] ? a : b));
                                                    
                                                    // UNIFIED APPROACH: Replace all existing labels with new ones using consistent positioning
                                                    console.log('Replacing all existing labels with unified positioning approach');
                                                    
                                                    // Hide all existing labels
                                                    xAxisCandidates.forEach((candidate) => {
                                                        candidate.element.style.display = 'none';
                                                    });
                                                    
                                                    // Calculate consistent Y position for all labels
                                                    let labelY = baselineY;
                                                    if (xAxisCandidates.length > 1) {
                                                        // Use a well-positioned existing label as reference and add offset for proper positioning
                                                        const referenceLabel = xAxisCandidates[1]; // Label "1" 
                                                        labelY = referenceLabel.y + 15; // Consistent offset for all labels
                                                    }
                                                    
                                                    // Create ALL 24 labels using the same unified method
                                                    for (let hour = 0; hour < 24; hour++) {
                                                        const newLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                                        newLabel.textContent = hour.toString();
                                                        
                                                        // Unified positioning: all labels use the same method
                                                        newLabel.setAttribute('x', hourPositions[hour].toString());
                                                        newLabel.setAttribute('y', labelY.toString());
                                                        newLabel.setAttribute('text-anchor', 'start'); // Left-align with bar's left edge
                                                        newLabel.setAttribute('font-family', 'Arial, sans-serif');
                                                        newLabel.setAttribute('font-size', isMobile ? '12' : '12');
                                                        newLabel.setAttribute('fill', 'white'); // Match Y-axis label color
                                                        newLabel.setAttribute('class', 'unified-hour-label');
                                                        
                                                        // Add to SVG
                                                        svg.appendChild(newLabel);
                                                        
                                                        if (hour < 8) {
                                                            console.log(`Unified label ${hour}: x=${hourPositions[hour].toFixed(1)}, y=${labelY.toFixed(1)} (under bar ${hour * 4})`);
                                                        }
                                                    }
                                                    
                                                    console.log(`Repositioned 24 hour labels across full width (${totalWidth}px) with integer offsets`);
                                                }
                                            }
                                        }
                                    } catch (error) {
                                        console.error('Error fixing labels:', error);
                                    }
                                }, 300); // Increased delay for orientation changes
                            });
                        }

                        chart.draw(chartData, options);
                        console.log('Chart created and cached for future redraws');
                    } catch (error) {
                        console.error('Error creating or drawing chart:', error);
                        chartElement.innerHTML = '<div style="color: white; padding: 20px;">Error creating chart: ' + error.message + '</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching chart data:', error);
                    chartElement.innerHTML = '<div style="color: white; padding: 20px;">Error loading chart data</div>';
                });
        }

        function startNowLineTimer(chart, chartElement, validData) {
            // Update the now line every minute
            const timer = setInterval(() => {
                updateNowLine(chart, chartElement, validData);
            }, 60000); // 60 seconds

            // Store timer reference for cleanup
            chartElement._nowLineTimer = timer;

            // Add visibility change listener to update now line when tab becomes visible
            const visibilityHandler = () => {
                if (!document.hidden) {
                    console.log('Tab became visible - updating now line immediately');
                    updateNowLine(chart, chartElement, validData);
                }
            };

            // Store handler reference for cleanup
            chartElement._visibilityHandler = visibilityHandler;
            document.addEventListener('visibilitychange', visibilityHandler);
        }

        function updateNowLine(chart, chartElement, validData) {
            try {
                // Only update if the document is visible (window is in foreground)
                if (document.hidden) {
                    console.log('Skipping now line update - document is hidden');
                    return;
                }

                // Remove existing now lines
                const existingLines = chartElement.querySelectorAll('.now-line');
                existingLines.forEach(line => line.remove());

                // Add new now line at current position
                addNowLineInternal(chart, chartElement, validData);
            } catch (error) {
                console.error('Error updating now line:', error);
            }
        }

        function drawMajorGridlines(chart, chartElement, minPrice, maxPrice) {
            try {
                console.log('drawMajorGridlines called with:', minPrice, 'to', maxPrice);

                // Remove any existing custom gridlines to prevent duplicates
                const existingLines = chartElement.querySelectorAll('.major-gridline, .minor-gridline, .custom-gridlines-group');
                existingLines.forEach(line => line.remove());

                const svgElement = chartElement.querySelector('svg');
                if (!svgElement) {
                    console.error('No SVG element found in chart');
                    return;
                }

                const chartLayout = chart.getChartLayoutInterface();
                const chartArea = chartLayout.getChartAreaBoundingBox();
                if (!chartArea) {
                    console.error('No chart area bounding box found');
                    return;
                }



                // Create a group element for all gridlines to ensure proper z-order
                const gridlinesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gridlinesGroup.setAttribute('class', 'custom-gridlines-group');

                // Draw all gridlines (1-cent intervals)
                let majorCount = 0;
                let minorCount = 0;



                for (let price = minPrice; price <= maxPrice; price += 1) {
                    try {
                        const yPosition = chartLayout.getYLocation(price);
                        const isMajor = price % 5 === 0;

                        // Create horizontal line
                        const gridLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        gridLine.setAttribute('class', isMajor ? 'major-gridline' : 'minor-gridline');
                        gridLine.setAttribute('x1', chartArea.left.toString());
                        gridLine.setAttribute('y1', yPosition.toString());
                        gridLine.setAttribute('x2', (chartArea.left + chartArea.width).toString());
                        gridLine.setAttribute('y2', yPosition.toString());

                        if (isMajor) {
                            // Major gridlines - thick and bright to avoid anti-aliasing
                            gridLine.setAttribute('stroke', '#aaaaaa');  // Bright gray for good visibility
                            gridLine.setAttribute('stroke-width', '2');  // Thick enough to avoid anti-aliasing
                            gridLine.setAttribute('opacity', '1.0');  // Full opacity
                            gridLine.setAttribute('style', 'stroke: #aaaaaa !important; stroke-width: 2px !important; opacity: 1.0 !important;');
                            gridLine.setAttribute('data-price', price.toString());  // Add data attribute for debugging

                        } else {
                            // Minor gridlines - thick enough to be consistent
                            gridLine.setAttribute('stroke', '#666666');  // Medium gray
                            gridLine.setAttribute('stroke-width', '1.5');  // Thick enough to avoid anti-aliasing
                            gridLine.setAttribute('opacity', '0.7');  // Good opacity
                            gridLine.setAttribute('style', 'stroke: #666666 !important; stroke-width: 1.5px !important; opacity: 0.7 !important;');

                        }

                        // Add gridline to the group
                        gridlinesGroup.appendChild(gridLine);

                        if (isMajor) majorCount++;
                        else minorCount++;
                    } catch (e) {
                        // Skip if getYLocation fails for this price
                        console.warn('Could not draw gridline for price:', price, e);
                    }
                }



                // Insert gridlines before data bars but after background
                // Find the first data element (usually a 'g' group containing bars)
                const dataGroups = svgElement.querySelectorAll('g');
                let dataGroup = null;

                // Look for a group that contains rect elements (the chart bars)
                for (let group of dataGroups) {
                    if (group.querySelector('rect')) {
                        dataGroup = group;
                        break;
                    }
                }

                if (dataGroup) {
                    svgElement.insertBefore(gridlinesGroup, dataGroup);

                } else {
                    // Fallback: insert at the beginning but after defs
                    let insertPoint = svgElement.firstChild;
                    while (insertPoint && (insertPoint.tagName === 'defs' || insertPoint.tagName === 'rect')) {
                        insertPoint = insertPoint.nextSibling;
                    }

                    if (insertPoint) {
                        svgElement.insertBefore(gridlinesGroup, insertPoint);

                    } else {
                        svgElement.appendChild(gridlinesGroup);

                    }
                }


            } catch (error) {
                console.error('Error drawing gridlines:', error);
            }
        }

        function addNowLine(chart, chartElement, validData) {
            // Initial draw - just call the internal function
            addNowLineInternal(chart, chartElement, validData);
        }

        function addNowLineInternal(chart, chartElement, validData) {
            try {
                // Remove any existing now lines to prevent duplicates
                const existingLines = chartElement.querySelectorAll('.now-line');
                existingLines.forEach(line => line.remove());

                // Get current time
                const now = new Date();
                const currentHour = now.getHours();
                const currentMinutes = now.getMinutes();

                // Find the SVG element in the chart
                const svgElement = chartElement.querySelector('svg');
                if (!svgElement) return;

                // Use Google Charts' getChartLayoutInterface to get precise positioning
                const chartLayout = chart.getChartLayoutInterface();
                const chartArea = chartLayout.getChartAreaBoundingBox();

                if (!chartArea) {
                    console.warn('Could not get chart area bounding box');
                    return;
                }

                // Find the data point index for the current time
                let dataPointIndex = -1;
                let currentTimeStr;

                // Check if we have granularity info to determine time format
                const granularity = chartElement._granularity || 'hour';
                if (granularity === 'quarter_hour') {
                    // For 15-minute data, find the closest 15-minute interval using sequential index
                    const quarter = Math.floor(currentMinutes / 15);
                    const intervalIndex = currentHour * 4 + quarter;
                    currentTimeStr = intervalIndex.toString();
                    dataPointIndex = validData.findIndex(row => row[0] === currentTimeStr);
                } else {
                    // For hourly data, use hour only
                    currentTimeStr = currentHour.toString();
                    dataPointIndex = validData.findIndex(row => row[0] === currentTimeStr);
                }

                let lineX;

                if (dataPointIndex >= 0) {
                    // Try to get the exact position using the data point index
                    try {
                        // Get the center position of the column for the current hour
                        lineX = chartLayout.getXLocation(dataPointIndex);
                    } catch (e) {
                        console.warn('getXLocation failed, using fallback calculation');
                        // Fallback calculation accounting for different groupWidth based on granularity
                        const granularity = chartElement._granularity || 'hour';

                        // Use standard calculation for both granularities
                        const totalColumns = validData.length;
                        const groupWidth = 0.7; // matches chart options
                        const effectiveWidth = chartArea.width * groupWidth;
                        const gapWidth = chartArea.width * (1 - groupWidth);
                        const columnWidth = effectiveWidth / totalColumns;
                        const gapPerColumn = gapWidth / (totalColumns + 1);

                        lineX = chartArea.left + gapPerColumn + (dataPointIndex * (columnWidth + gapPerColumn)) + (columnWidth / 2);
                    }
                } else {
                    // Time not found in data, calculate position accounting for gaps and actual bar positions
                    const granularity = chartElement._granularity || 'hour';

                    // Calculate position based on time, accounting for the data structure
                    let approximateIndex;
                    if (granularity === 'quarter_hour') {
                        // For 15-minute data, calculate approximate index in the 96-item array
                        const quarter = Math.floor(currentMinutes / 15);
                        const minuteProgress = (currentMinutes % 15) / 15;
                        approximateIndex = (currentHour * 4) + quarter + minuteProgress;
                    } else {
                        // For hourly data, calculate approximate index in the 24-item array
                        const minuteProgress = currentMinutes / 60;
                        approximateIndex = currentHour + minuteProgress;
                    }

                    // Use standard spacing calculation
                    const totalColumns = granularity === 'quarter_hour' ? 96 : 24;
                    const groupWidth = 0.7; // matches chart options
                    const effectiveWidth = chartArea.width * groupWidth;
                    const gapWidth = chartArea.width * (1 - groupWidth);
                    const columnWidth = effectiveWidth / totalColumns;
                    const gapPerColumn = gapWidth / (totalColumns + 1);

                    lineX = chartArea.left + gapPerColumn + (approximateIndex * (columnWidth + gapPerColumn));
                }

                // Create yellow line (thin and dotted for 15-minute bars)
                const nowLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                nowLine.setAttribute('class', 'now-line');
                nowLine.setAttribute('x1', lineX.toString());
                nowLine.setAttribute('y1', chartArea.top.toString());
                nowLine.setAttribute('x2', lineX.toString());
                nowLine.setAttribute('y2', (chartArea.top + chartArea.height).toString());
                nowLine.setAttribute('stroke', '#ff9900');
                nowLine.setAttribute('stroke-width', '3');
                nowLine.setAttribute('stroke-dasharray', '4,3');
                nowLine.setAttribute('opacity', '0.9');

                svgElement.appendChild(nowLine);

                console.log('Now line positioned at time', currentTimeStr, 'data index', dataPointIndex, 'x-position', lineX);
            } catch (error) {
                console.error('Error adding now line:', error);
            }
        }

        // Initialize chart
        if (typeof google !== 'undefined' && google.charts) {
            google.charts.load('current', { packages: ['corechart'] });
            google.charts.setOnLoadCallback(drawChart);
        } else {
            // If Google Charts isn't loaded yet, wait for it
            const checkGoogle = setInterval(() => {
                if (typeof google !== 'undefined' && google.charts) {
                    clearInterval(checkGoogle);
                    google.charts.load('current', { packages: ['corechart'] });
                    google.charts.setOnLoadCallback(drawChart);
                }
            }, 100);
        }
    };

    // Execute the chart creation function immediately
    window.createChart_{{chart_date }} ();
</script>
